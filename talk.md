# hell

![alt tag](http://icompile.eladkarako.com/wp-content/uploads/2016/01/icompile.eladkarako.com_callback_hell.gif)

# callback hell

![alt tag](https://brunolm.files.wordpress.com/2017/01/hadouken-code.jpg)

# promise hell

![alt tag](http://steelkiwi.com/media/markdownx/e14ecb1d-ccc2-4d32-b682-0da479ad7ae9.png)

# async/await hell

??


# Парадигмы программирования
https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F


 * Императивная (контрастирует с декларативной)
     * Процедурная
     * Структурная
     * Аспектно-ориентированная
     * Объектно-ориентированная
          * Агентно-ориентированная
          * Компонентно-ориентированная
          * Прототипно-ориентированная
     * Обобщённое программирование
 * Декларативная (контрастирует с императивной)
     * Чистота языка
          * Чистота функции
     * Функциональная
          * В терминах Рефал-машины
          * Аппликативная
          * Комбинаторная
          * Бесточечная
              * (чистая конкатенативная)
     * Логическая
          * Ограничениями
 * Конкатенативная
 * Векторная
 * Метапрограммирование
   * Языково-ориентированная
     * Предметно-ориентированная
     * Пользователями
   * Автоматизация процесса программирования
   * Рефлексивность
    * Гомоиконность
 * Связанные темы
     * Программирование в крупном и мелком масштабе
     * Модульность
     * Полиморфизм
     * Продолжения и CPS
     * Параллелизм и конкурентность
 * Методы и алгоритмы
     * Автоматное
     * Динамическое
     * Потоков данных
     * Событийно-ориентированное
     * Реактивное
     * Сервис-ориентированное

Парадигма программирования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.

Важно отметить, **что парадигма программирования не определяется однозначно языком программирования**; практически все современные языки программирования в той или иной мере допускают использование различных парадигм (мультипарадигмальное программирование). Так, на языке Си, который не является объектно-ориентированным, можно работать в соответствии с принципами объектно-ориентированного программирования, хотя это и сопряжено с определёнными сложностями; функциональное программирование можно применять при работе на любом императивном языке, в котором имеются функции, и т. д.

Также важно отметить, **что существующие парадигмы зачастую пересекаются друг с другом в деталях** (например модульное и объектно-ориентированное программирование), поэтому можно встретить ситуации, когда разные авторы употребляют названия из разных парадигм, говоря при этом, по сути, об одном и том же явлении.

```
Слово «парадигма» используется в программировании для определения семейства обозначений (нотаций), разделяющих общий способ (методику) реализаций программ.

(c) Спинеллис, Диомидис
```

## Основные модели программирования

### Императивное программирование

Императи́вное программи́рование — это парадигма программирования (стиль написания исходного кода компьютерной программы), для которого характерно следующее:

 * в исходном коде программы записываются инструкции (команды);
 * инструкции должны выполняться последовательно;
 * при выполнении инструкции данные, полученные при выполнении предыдущих инструкций, могут читаться из памяти;
 * данные, полученные при выполнении инструкции, могут записываться в память.
 
Императивная программа похожа на приказы (англ. imperative — приказ, повелительное наклонение), выражаемые повелительным наклонением в естественных языках, то есть представляют собой последовательность команд, которые должен выполнить компьютер.
При императивном подходе к составлению кода (в отличие от функционального подхода, относящегося к декларативной парадигме) широко используется присваивание. Наличие операторов присваивания увеличивает сложность модели вычислений и делает императивные программы подверженными специфическим ошибкам, не встречающимся при функциональном подходе.
 * Основные черты императивных языков:
 * использование именованных переменных;
 * использование оператора присваивания;
 * использование составных выражений;
 * использование подпрограмм;
 * и др.

### Декларативное программирование

Декларати́вное программи́рование — это парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается, что представляет собой проблема и ожидаемый результат. Противоположностью декларативного является императивное программирование, описывающее на том или ином уровне детализации, как решить задачу и представить результат. В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное — от машины к человеку. Как следствие, декларативные программы не используют понятия состояния, то есть не содержат переменных и операторов присваивания (см. также ссылочная прозрачность).

Наиболее близким к «чисто декларативному» программированию является написание исполнимых спецификаций (см. соответствие Карри — Ховарда). В этом случае программа представляет собой формальную теорию, а её выполнение является одновременно автоматическим доказательством этой теории, и характерные для императивного программирования составляющие процесса разработки (проектирование, рефакторинг, отладка и др.) в этом случае исключаются: программа проектирует и доказывает сама себя.

К подвидам декларативного программирования также зачастую относят функциональное и логическое программирование — несмотря на то, что программы на таких языках нередко содержат алгоритмические составляющие, архитектура в императивном понимании (как нечто отдельное от кодирования) в них также отсутствует: схема программы является непосредственно частью исполняемого кода.

На повышение уровня декларативности нацелено языково-ориентированное программирование.

«Чисто декларативные» компьютерные языки зачастую не полны по Тьюрингу — примерами служат SQL и HTML — так как теоретически не всегда возможно порождение исполняемого кода по декларативному описанию. Это иногда приводит к спорам о корректности термина «декларативное программирование» (менее спорным является «декларативное описание решения» или, что то же самое, «декларативное описание задачи»).


### Структурное программирование

Структу́рное программи́рование — методология разработки программного обеспечения, в основе которой лежит представление программы в виде иерархической структуры блоков. Предложена в 1970-х годах Э. Дейкстрой и др.

В соответствии с данной методологией любая программа строится без использования оператора goto из трёх базовых управляющих структур: последовательность, ветвление, цикл; кроме того, используются подпрограммы. При этом разработка программы ведётся пошагово, методом «сверху вниз».

Методология структурного программирования появилась как следствие возрастания сложности решаемых на компьютерах задач, и соответственно, усложнения программного обеспечения. В 1970-е годы объёмы и сложность программ достигли такого уровня, что традиционная (неструктурированная) разработка программ перестала удовлетворять потребностям практики. Программы становились слишком сложными, чтобы их можно было нормально сопровождать. Поэтому потребовалась систематизация процесса разработки и структуры программ.

Методология структурной разработки программного обеспечения была признана «самой сильной формализацией 70-х годов».

По мнению Бертрана Мейера, «Революция во взглядах на программирование, начатая Дейкстрой, привела к движению, известному как структурное программирование, которое предложило систематический, рациональный подход к конструированию программ. Структурное программирование стало основой всего, что сделано в методологии программирования, включая и объектное программирование»[1].

### Функциональное программирование

Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).

Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.

Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).

На практике отличие математической функции от понятия «функции» в императивном программировании заключается в том, что императивные функции могут опираться не только на аргументы, но и на состояние внешних по отношению к функции переменных, а также иметь побочные эффекты и менять состояние внешних переменных. Таким образом, в императивном программировании при вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных. А в функциональном языке при вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных. Это позволяет средам выполнения программ на функциональных языках кешировать результаты функций и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо дополнительных действий со стороны программиста (что обеспечивают функции без побочных эффектов — чистые функции[⇨]).

Лямбда-исчисление являются основой для функционального программирования, многие функциональные языки можно рассматривать как «надстройку» над ними[1].


### Логическое программирование

Логи́ческое программи́рование — парадигма программирования, основанная на автоматическом доказательстве теорем, а также раздел дискретной математики, изучающий принципы логического вывода информации на основе заданных фактов и правил вывода. Логическое программирование основано на теории и аппарате математической логики с использованием математических принципов резолюций.

Самым известным языком логического программирования является Prolog.

Первым языком логического программирования был язык Planner, в котором была заложена возможность автоматического вывода результата из данных и заданных правил перебора вариантов (совокупность которых называлась планом). Planner использовался для того, чтобы понизить требования к вычислительным ресурсам (с помощью бэктрекинга — поиска с возвратом) и обеспечить возможность вывода фактов, без активного использования стека. Затем был разработан язык Prolog, который не требовал плана перебора вариантов и был, в этом смысле, упрощением языка Planner.

От языка Planner также произошли логические языки программирования QA-4, Popler, Conniver и QLISP. Языки программирования Mercury, Visual Prolog, Oz и Fril произошли уже от языка Prolog. На базе языка Planner было разработано также несколько альтернативных языков логического программирования, не основанных на методе поиска с возвратами), например, Ether).


### Объектно-ориентированное программирование

Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Необходимо обратить внимание на следующие важные части этого определения: 1) объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы; 2) каждый объект является экземпляром определенного класса; 3) классы образуют иерархии. Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.
 
   * Программирование, основанное на классах

    Класс-ориентированное программирование — это программирование, сфокусированное на данных, причём данные и поведение неразрывно связаны между собой. Вместе данные и поведение представляют собой класс. Соответственно в языках, основанных на понятии «класс», все объекты разделены на два основных типа — классы и экземпляры. Класс определяет структуру и функциональность (поведение), одинаковую для всех экземпляров данного класса. Экземпляр является носителем данных — то есть обладает состоянием, меняющимся в соответствии с поведением, заданным классом. В класс-ориентированных языках новый экземпляр создаётся через вызов конструктора класса (возможно, с набором параметров). Получившийся экземпляр имеет структуру и поведение, жёстко заданные его классом.

   * Программирование, основанное на прототипах

      Прототипное программирование, сохранив часть черт ООП, отказалось от базовых понятий — класса и наследования.
      
      * Прототип — это объект-образец, по образу и подобию которого создаются другие объекты. Объекты-копии могут сохранять связь с родительским объектом, автоматически наследуя изменения в прототипе; эта особенность определяется в рамках конкретного языка.
      * Вместо механизма описания классов и порождения экземпляров язык предоставляет механизм создания объекта (путём задания набора полей и методов, которые объект должен иметь) и механизм клонирования объектов.
      * Каждый вновь созданный объект является «экземпляром без класса». Каждый объект может стать прототипом — быть использован для создания нового объекта с помощью операции клонирования. После клонирования новый объект может быть изменён, в частности, дополнен новыми полями и методами.
      * Клонированный объект либо становится полной копией прототипа, хранящей все значения его полей и дублирующей его методы, либо сохраняет ссылку на прототип, не включая в себя клонированных полей и методов до тех пор, пока они не будут изменены. В последнем случае среда исполнения обеспечивает механизм делегирования — если при обращении к объекту он сам не содержит нужного метода или поля данных, вызов передаётся прототипу, от него, при необходимости — дальше по цепочке.

   * Компонентно-ориентированное программирование
   
      Компонентно-ориентированное программирование — это своеобразная «надстройка» над ООП, набор правил и ограничений, направленных на построение крупных развивающихся программных систем с большим временем жизни. Программная система в этой методологии представляет собой набор компонентов с хорошо определёнными интерфейсами. Изменения в существующую систему вносятся путём создания новых компонентов в дополнение или в качестве замены ранее существующих. При создании новых компонентов на основе ранее созданных запрещено использование наследования реализации — новый компонент может наследовать лишь интерфейсы базового. Таким образом компонентное программирование обходит проблему хрупкости базового класса.

## Еще

 * Процедурное программирование
 
    программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка.
    
 * Аппликативное программирование
 
    Аппликативное программирование — один из видов декларативного программирования, в котором написание программы состоит в систематическом осуществлении применения одного объекта к другому. Результатом такого применения вновь является объект, который может участвовать в применениях как в роли функции, так и в роли аргумента и так далее. Это делает запись программы математически ясной. Тот факт, что функция обозначается выражением, свидетельствует о возможности использования значений-функций — функциональных объектов — на равных правах с прочими объектами, которые можно передавать как аргументы, либо возвращать как результат вычисления других функций.
 
 * Обобщённое программирование
 
    Обобщённое программирование (англ. generic programming) — парадигма программирования, заключающаяся в таком описании данных и алгоритмов, которое можно применять к различным типам данных, не меняя само это описание. В том или ином виде поддерживается разными языками программирования. Возможности обобщённого программирования впервые появились в виде дженериков (обобщённых функций) в 1970-х годах в языках Клу и Ада, затем в виде параметрического полиморфизма в ML и его потомках, а затем во многих объектно-ориентированных языках, таких как C++, Java, Object Pascal, D, Eiffel, языках для платформы .NET и других.
 
 * Доказательное программирование
 
    Доказательное программирование — использовавшаяся в 1980-х годах в академических кругах технология разработки программ для ЭВМ с доказательствами правильности — доказательствами отсутствия ошибок в программах (понимая, в рамках данной теории, ошибки как несоответствия между программой и реализуемым ею алгоритмом).
    
 * Порождающее программирование
 
  Порождающее программирование (generative programming) – парадигма технологии разработки программного обеспечения, основанная на моделировании семейства программных систем, используя которые можно по конкретным техническим требованиям автоматически получить специализированный и оптимизированный промежуточный или конечный программный продукт из элементарных, многократно используемых компонентов реализации с помощью базы знаний о конфигурациях .
 
  Порождающее программирование фокусирует внимание не на уникальных продуктах (объектах), а на семействах программных систем (классах объектов). Таким образом, порождающее программирование имеет огромное сходство с теорией универсальных и интегративных моделей, применяемых для синтеза объектов, и являющихся моделями не отдельно взятого объекта, а моделями всех объектов, принадлежащих рассматриваемому классу (моделью семейства объектов или систем).
 
  Таким образом, порождающее программирование – это автоматизированное производство программных продуктов из отдельных компонентов, на манер того, как это происходит при производстве промышленных изделий, в частности автомобилей. Ключевыми моментами здесь являются унификация, автоматизация и гибкость. Так современные сборочные линии позволяют создавать автомобили с различными конфигурациями. Например, для автомобиля Mercedes-Benz класса E имеется 8000 вариантов водительских мест и 10 000 вариантов сидений .
 
 * Аспектно-ориентированное программирование
 
  Аспе́ктно-ориенти́рованное программи́рование (АОП) — парадигма программирования, основанная на идее разделения функциональности для улучшения разбиения программы на модули. Методология АОП была предложена группой инженеров исследовательского центра Xerox PARC под руководством Грегора Кичалеса (Gregor Kiczales).
  
 * Агентно-ориентированное программирование
 
  Агентно-ориентированный подход (в дальнейшем АОП) к программированию — разновидность представления программ или парадигма программирования, в которой основополагающими концепциями являются понятия агента и его ментальное поведение, зависящее от среды, в которой он находится. Концепция была предложена Шохемом (англ. Yoav Shoham) в 1990 г.. Определение парадигмы, данное автором:
  
  «	Эту новую парадигму программирования вполне разумно назвать рациональным программированием. Точно так же, как объектно-ориентированное программирование сдвинуло парадигму с написания процедур к созданию объектов, рациональное программирование сдвинуло парадигму с создания информационных объектов к созданию мотивированных агентов.	»
  
  Агентом является всё, что может рассматриваться как воспринимающее свою среду с помощью датчиков и воздействующее на эту среду с помощью исполнительных механизмов.
  
 * Автоматное программирование
   
   Автома́тное программи́рование — это парадигма программирования, при использовании которой программа или её фрагмент осмысливается как модель какого-либо формального автомата. Известна также и другая "парадигма автоматного программирования, состоящая в представлении сущностей со сложным поведением в виде автоматизированных объектов управления, каждый из которых представляет собой объект управления и автомат". При этом о программе, как в автоматическом управлении, предлагается думать как о системе автоматизированных объектов управления.
   
   В зависимости от конкретной задачи в автоматном программировании могут использоваться как конечные автоматы, так и автоматы с более сложным строением.
   
   Определяющими для автоматного программирования являются следующие особенности:
   
    * временной период выполнения программы разбивается на шаги автомата, каждый из которых представляет собой выполнение определённой (одной и той же для каждого шага) секции кода с единственной точкой входа; такая секция может быть оформлена, например, в виде отдельной функции и может быть разделена на подсекции, соответствующие отдельным состояниям или категориям состояний
   
    * передача информации между шагами автомата осуществляется только через явно обозначенное множество переменных, называемых состоянием автомата; между шагами автомата программа (или её часть, оформленная в автоматном стиле) не может содержать неявных элементов состояния, таких как значения локальных переменных в стеке, адреса возврата из функций, значение текущего счётчика команд и т. п.; иначе говоря, состояние программы на любые два момента входа в шаг автомата могут различаться между собой только значениями переменных, составляющих состояние автомата (причём такие переменные должны быть явно обозначены в качестве таковых).
   
   Полностью выполнение кода в автоматном стиле представляет собой цикл (возможно, неявный) шагов автомата.
   
   Название автоматное программирование оправдывается ещё и тем, что стиль мышления (восприятия процесса исполнения) при программировании в этой технике практически точно воспроизводит стиль мышления при составлении формальных автоматов (таких как машина Тьюринга, автомат Маркова и др.)
   
 
 * Событийно-ориентированное программирование
 
   Событи́йно-ориенти́рованное программи́рование (англ. event-driven programming; в дальнейшем СОП) — парадигма программирования, в которой выполнение программы определяется событиями — действиями пользователя (клавиатура, мышь), сообщениями других программ и потоков, событиями операционной системы (например, поступлением сетевого пакета).
   
   СОП можно также определить как способ построения компьютерной программы, при котором в коде (как правило, в головной функции программы) явным образом выделяется главный цикл приложения, тело которого состоит из двух частей: выборки события и обработки события.
   
   Как правило, в реальных задачах оказывается недопустимым длительное выполнение обработчика события, поскольку при этом программа не может реагировать на другие события. В связи с этим при написании событийно-ориентированных программ часто применяют автоматное программирование.
 
 * Компонентно-ориентированное программирование
 
    Компонентно-ориентированное программирование (англ. component-oriented programming, COP) — парадигма программирования, существенным образом опирающаяся на понятие компонента — независимого модуля исходного кода программы, предназначенного для повторного использования и развёртывания и реализующегося в виде множества языковых конструкций (например, «классов» в объектно-ориентированных языках программирования), объединённых по общему признаку и организованных в соответствии с определёнными правилами и ограничениями.
 
 * Грамотное программирование

  Грамотное программирование (ГП; англ. Literate Programming) — концепция, методология программирования и документирования, в которой программа состоит из прозы на естественном языке вперемежку с макроподстановками и кодом на языках программирования. Термин и саму концепцию предложил Дональд Кнут в 1981 году при разработке системы компьютерной вёрстки TeX.
  
  Грамотное программирование подобно объяснениям на лекциях по программированию, использующим фразы на «псевдокоде» на естественном языке. Они вносят ясность в сложный код и скрывают под одной фразой множество других вложенных абстракций и программного кода на формальном языке программирования.
  
  ГП в некотором смысле есть «программирование на псевдокоде» произвольными фразами, которые затем раскрываются как макросы с помощью утилиты из исходного файла, который включает в себя одновременно документированные текстовые объяснения концепций, сам код и псевдокод.

# Реактивное программирование

Реактивное программирование — парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.

К примеру, в императивном программировании присваивание a := b + c будет означать, что переменной a будет присвоен результат выполнения операции b + c, используя текущие (на момент вычисления) значения переменных. Позже значения переменных b и c могут быть изменены без какого-либо влияния на значение переменной a.

В реактивном же программировании значение a будет автоматически пересчитано, основываясь на новых значениях.

Современные табличные процессоры представляют собой пример реактивного программирования. Ячейки таблицы могут содержать строковые значения или формулу вида «=B1+C1», значение которой будет вычислено исходя из значений соответствующих ячеек. Когда значение одной из зависимых ячеек будет изменено, значение этой ячейки будет автоматически обновлено.

Другой пример — это языки описания аппаратуры (HDL), такие как Verilog. Реактивное программирование позволяет моделировать изменения в виде их распространения внутри модели.

Реактивное программирование предлагалось как путь для лёгкого создания пользовательских интерфейсов, анимации или моделирования систем, изменяющихся во времени.

К примеру, в MVC архитектуре с помощью реактивного программирования можно реализовать автоматическое отражение изменений из Model в View и наоборот из View в Model.

## Реактивные подходы к программированию

### Императивное реактивное программирование
Можно соединить парадигмы реактивного и императивного программирования. В такой связке императивные программы могли бы работать над реактивными структурами данных.

### Объектно-ориентированное реактивное программирование
Объектно-ориентированное реактивное программирование (ООРП) — это комбинация объектно-ориентированного подхода с реактивным. Вероятно, наиболее естественный способ сделать это состоит в том, что вместо методов и полей, у объектов есть реакции, которые автоматически пересчитывают значения и другие реакции зависят от изменений этих значений.

### Функциональное реактивное программирование
Функциональное программирование является наиболее естественным базисом для реализации реактивной архитектуры, хорошо сочетаясь с параллелизмом.
Функциональное реактивное программирование (ФРП) сформировалось в 1997 году, с предложением языка Fran. Позже были разработаны такие языки как Fruit, FRP и RT-FRP, FAL, Frob, Fvision, Yampa.
Простейшее функциональное реактивное выражение имеет следующую форму:
```
b1 `until` e => b2
```
что буквально означает «вести себя как b1 до возникновения события e, после этого вести себя как b2».


# паттерны 

http://public.jugru.org/holyjs/2016/spb/day_1/track_1/rusakovich.pdf

![alt tag](https://lh3.googleusercontent.com/-t7JXfsD7J_U/VKi1lbT5ZvI/AAAAAAAALms/g7-1psSs4pM/w800-h800/How%2Bto%2Buse%2BGOF%2BDesign%2BPatterns.gif)


# основные игроки реактивных библиотек
https://dou.ua/lenta/articles/reactive-libraries/

Observable, Observer, Subscriber
Давайте посмотрим на основных игроков реактивных библиотек: Observable, Observer и Subscriber.

Observable — это объект или функция, которая выдает последовательности данных во времени (a.k.a. The Producer).

Observer — это объект или функция, которая знает, как обрабатывать последовательности данных (a.k.a. The Consumer).

Subscriber — это объект или функция, которая связывает Observable и Observer.


Я думаю многие из работающих программистов, увидев это диаграмму, скажут, что мы это и так знаем — обычный messaging и pub-sub. Это и так, и не так:

Rx библиотеки заточены на асинхронную обработку без блокировки обработки данных.

Rx предлагает простой API с выделенными каналами для передачи данных, ошибок и сигнала об окончании потока данных.

В Rx библиотеках есть больше сотни операторов, которыми можно обрабатывать потоки идущие к подписчику. Операторы можно собирать в цепочки, т.е операторы composable.

В некоторых реализациях RX, например, RxJava2, хорошо поддерживается backpressure, т.е. ситуация, когда продюсер выдает данные быстрее, чем подписчик может обработать.

Для Rx messaging не нужно поднимать специальные серверы. Все включено в код вашего приложения.

В языках, которые поддерживают multi-threading, работа со threads упрощается, как и переключения с одних threads на другие. Разработчики на Андроиде — это оценят, ибо там вывод на экран всегда должен выполняться main thread, а вычисления — другими.

Как же все-таки Observable передает данные в Observer? Observer может имплементировать три метода (названия могут слегка отличаться в зависимости от языка):

next() - вот тебе новое значение из потока;

error() - вот тебе ошибка, произошедшая в потоке;

complete() - поток завершен.

В следующем примере функция getData() превращает массив с пивом в Observable и возвращает его. Кому? Подписчику, когда он появится. А подписчик — getData().subscribe(...​) - передает Observer, как аргумент функции subscribe(). Соответственно, Observer состоит из трех функций:

что делать, когда придет следующий элемент потока;

что делать, если придет ошибка;

что делать, если придет сигнал об окончании потока.


![alt tag](https://s.dou.ua/storage-files/operators.png)

# примеры из rxmarbles.com
http://rxmarbles.com/
