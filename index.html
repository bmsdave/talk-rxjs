<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Реактивный подход в разработке (RxJS)</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">
		<link rel="stylesheet" href="css/styles.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>RxJS</h1>
					<h3>Реактивный подход в разработке</h3>
					<img src="./images/stream.jpeg"></img>
				</section>
				<section>
					<section>
						<img src="./images/hell.gif" height="100%" width="100%"></img>
					</section>
					<section>
						<img src="./images/callback-hell.jpg" height="100%" width="100%"></img>
					</section>
					<section>
						<img src="./images/promise-hell.png" height="100%" width="100%"></img>
					</section>
					<section>
						<h2>...</h2>
					</section>
					<section>
						<h2>async await!</h2>
					</section>
				</section>
				<section>
					<section>
						<h2>Парадигмы программирования</h2>
						<img src="./images/ruwiki.png"></img>
					</section>
					<section>
						<h4>Императивная (контрастирует с декларативной)</h4>
						<ul>
							<li>Процедурная</li>
							<li>Структурная</li>
							<li>Аспектно-ориентированная</li>
							<li>Объектно-ориентированная</li>
							<ul>
								<li>Агентно-ориентированная</li>
								<li>Компонентно-ориентированная</li>
								<li>Прототипно-ориентированная</li>
							</ul>
							<li>Обобщённое программирование</li>
						</ul>
					</section>
					<section>
						<h4>Декларативная (контрастирует с императивной)</h4>
							<ul>
								<li>Чистота языка
									<ul>
										<li>Чистота функции</li>
									</ul>
								</li>	
								<li>Функциональная
								<ul> 
									<li>В терминах Рефал-машины</li>
									<li>Аппликативная</li>
									<li>Комбинаторная</li>
									<li>Бесточечная</li>
										<ul><li>(чистая конкатенативная)</li></ul>
								</ul>
								</li>
								<li>Логическая</li>
							</ul>
					</section>
					<section>
						<ul>
							<li>Конкатенативная</li>
							<li>Векторная</li>
							<li>Метапрограммирование
								<ul>
									<li>Языково-ориентированная</li>
									<ul>
										<li>Предметно-ориентированная</li>
										<li>Пользователями</li>
									</ul>
								</ul>
							</li>
							<li>Методы и алгоритмы
								<ul>
									<li>Автоматное</li>
									<li>Динамическое</li>
									<li>Потоков данных</li>
									<li>Событийно-ориентированное</li>
									<li>Реактивное</li>
									<li>Сервис-ориентированное</li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<h3>Грамотное/литературное программирование (Literate Programming)</h3>
						<p>программа состоит из прозы на естественном языке вперемежку с макроподстановками и кодом на языках программирования</p>
					</section>
					<section>
						<blockquote>
							Давайте изменим традиционные приоритеты в создании программ: вместо представления о нашей задаче как о создании инструкций «Что делать?» для компьютера сконцентрируемся на объяснении другим людям описаний нашего видения того, что под управлением программы должен делать компьютер.
							<br>— Дональд Кнут
						</blockquote>
					</section>
				</section>
				<section>
					<section>
						<h3>Реактивное программирование</h3>
						<p>Парадигма, ориентированная на потоки данных и распространение изменений.
						</p>
						<!--К примеру, в императивном программировании присваивание a := b + c будет означать,
						что переменной a будет присвоен результат выполнения операции b + c, используя текущие
						(на момент вычисления) значения переменных. Позже значения переменных b и c могут быть
						изменены без какого-либо влияния на значение переменной a.

						В реактивном же программировании значение a будет автоматически пересчитано, основываясь
						на новых значениях.

						Современные табличные процессоры представляют собой пример реактивного программирования.
						Ячейки таблицы могут содержать строковые значения или формулу вида «=B1+C1», значение
						которой будет вычислено исходя из значений соответствующих ячеек. Когда значение одной
						из зависимых ячеек будет изменено, значение этой ячейки будет автоматически обновлено.

						Другой пример — это языки описания аппаратуры (HDL), такие как Verilog. Реактивное
						программирование позволяет моделировать изменения в виде их распространения внутри модели.

						Реактивное программирование предлагалось как путь для лёгкого создания пользовательских
						интерфейсов, анимации или моделирования систем, изменяющихся во времени.

						К примеру, в MVC архитектуре с помощью реактивного программирования можно реализовать
						автоматическое отражение изменений из Model в View и наоборот из View в Model.-->						
					</section>
					<section>
						<h3> Реактивные подходы к программированию</h3>
					</section>
					<section>
						<h3>Императивное реактивное программирование</h3>
						<p>Императивные программы могли бы работать над реактивными структурами данных.
						</p>
					</section>
					<section>
						<h3>Объектно-ориентированное реактивное программирование</h3>
						<p>Вероятно, наиболее естественный
							способ сделать это состоит в том, что вместо методов и полей, у объектов есть
							реакции, которые автоматически пересчитывают значения и другие реакции зависят от изменений этих значений.
						</p>
					<!--<section>
						<h3> Object-oriented reactive programming </h3>
						<p>Instead of methods and fields, objects have reactions that automatically re-evaluate when the other reactions they depend on have been modified.</p>
					</section>-->
					</section>
					<section>	
						<h3>Функциональное реактивное программирование</h3>
						<p>
							Является наиболее естественным базисом для реализации реактивной
							архитектуры, хорошо сочетаясь с параллелизмом.
						</p>
					</section>
					<section>	
						<h3>1997. Fran.</h3>
						<p>Conal Elliott and Paul Hudak</p>
					</section>
					<section>
						<blockquote>
							Fran is a collection of data types and functions for composing richly interactive, multimedia animations.
						</blockquote>
					</section>
					<section>	
						<h3>b1 `until` e => b2</h3>
						<p>
							вести себя как b1 до возникновения события e, после этого вести себя как b2.
						</p>
					</section>
					<!--<section>
						<h3> Functional reactive programming </h3>
						<p> Functional Reactive Programming is a variant of Reactive Programming that follows Functional Programming principles such as referential transparency, and seeks to be purely functional. </p>
						<a href="https://medium.com/@andrestaltz/why-i-cannot-say-frp-but-i-just-did-d5ffaa23973b#.8sx7elq7v">Why I cannot say FRP but I just did</a>
					</section>-->
				</section>
				<section>	
					<section>
						<h3>Реализации в JS:</h3>
						<ul>
							<li class="fragment"> <strong> Bacon.js </strong> </li>
							<li class="fragment"> <strong> Cycle.js </strong> </li>
							<li class="fragment"> <strong> Elm </strong> </li>
							<li class="fragment"> <strong> Kefir </strong></li>
							<li class="fragment"> <strong> RxJS </strong> </li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Reactive Revolution</h2>
						<blockquote  class="fragment">ReactiveX is more than an API, it's an idea and a breakthrough in programming. It has inspired several other APIs, frameworks, and even programming languages.</blockquote>
					</section>
					<section>
						<h4 id="languages">Языки</h4>

						<ul>
							<li>Java: <a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
							<li>JavaScript: <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a></li>
							<li>C#: <a href="https://github.com/Reactive-Extensions/Rx.NET">Rx.NET</a></li>
							<li>C#(Unity): <a href="https://github.com/neuecc/UniRx">UniRx</a></li>
							<li>Scala: <a href="https://github.com/ReactiveX/RxScala">RxScala</a></li>
							<li>Clojure: <a href="https://github.com/ReactiveX/RxClojure">RxClojure</a></li>
							<li>C++: <a href="https://github.com/Reactive-Extensions/RxCpp">RxCpp</a></li>
							<li>Ruby: <a href="https://github.com/Reactive-Extensions/Rx.rb">Rx.rb</a></li>
							<li>Python: <a href="https://github.com/ReactiveX/RxPY">RxPY</a></li>
							<li>Groovy: <a href="https://github.com/ReactiveX/RxGroovy">RxGroovy</a></li>
							<li>JRuby: <a href="https://github.com/ReactiveX/RxJRuby">RxJRuby</a></li>
							<li>Kotlin: <a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a></li>
							<li>Swift: <a href="https://github.com/kzaher/RxSwift">RxSwift</a></li>
							<li>PHP: <a href="https://github.com/ReactiveX/RxPHP">RxPHP</a></li>
						</ul>
					</section>
					<section>
						<h4 id="reactivex-for-platforms-and-frameworks">ReactiveX для платформ и фреймворков</h4>

						<ul>
							<li><a href="https://github.com/ReactiveX/RxNetty">RxNetty</a></li>
							<li><a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></li>
							<li><a href="https://github.com/kzaher/RxSwift">RxCocoa</a></li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>RxJS</h2>
						<p>Set of libraries to compose asynchronous and event-based programs using observable collections and Array#extras style composition in JavaScript</p>
					</section>
					<section>
						<h3>Observable, Observer, Subscriber, Operators</h3>
					</section>
					<section>
						<p><strong>Observable</strong> — это объект или функция, которая выдает последовательности данных во времени.</p>
					</section>
					<section>				
						<p><strong>Observer</strong> — это объект или функция, которая знает, как обрабатывать последовательности данных.</p>
					</section>
					<section>
						<p><strong>Subscriber</strong> — это объект или функция, которая связывает Observable и Observer.</p>
					</section>
					<section>
						<img src="./images/oos.png" height="100%" width="100%"></img>
					</section>
					<section>
						<p><strong>Operators</strong>  — это функции, которыми можно преобразовывать данные между моментом, когда Observable их отправил, и моментом, когда подписчик их получил. </p>
					</section>
					<section>
						<img src="./images/rx_operators.png" height="100%" width="100%"></img> 
					</section>
				</section>
				<section>
					<section>
						<h1>Observable</h1>
						<video src="./observable.webm" autoplay loop>
							Your browser does not support the <code>video</code> element.
						</video>
					</section>
					<section>
						<h3>Создание observable</h3>
							<pre><code class="hljs javascript">
var observable = Rx.Observable.create(function (observer) {
  observer.next(1);
  observer.next(2);
  observer.next(3);
  setTimeout(() => {
    observer.next(4);
    observer.complete();
  }, 1000);
});
							</code></pre>
					</section>
					<section>
						<h3>Создание observable из event</h3>
							<pre><code class="hljs javascript">
window.onload = function() {
  var button = document.querySelector('button');
  
  var observable = Rx.Observable.fromEvent(button,  'click');
  
  observable.subscribe((event) => {
    console.log('Observable: ', event);
  });

  button.addEventListener('click', (event) => {
    console.log('Event listener: ', event);
  });
}
							</code></pre>
					</section>
					<section>
						<h3>Подписка на observable</h3>
							<pre><code class="hljs javascript">
observable.subscribe(
  (x) => console.log('got value ' + x),
  (err) => console.error('something wrong occurred: ' + err),
  () => console.log('done')
);
							</code></pre>
					</section>
					<section>
						<h3>Observables можно создать на:</h3>
						<ul>
							<li class="fragment">Array</li>
							<li class="fragment">Array-like object (e.g. DOM elements)</li>
							<li class="fragment">Event</li>
							<li class="fragment">Iterable object</li>
							<li class="fragment">Observable-like</li>
							<li class="fragment">Promise</li>
						</ul>
					</section>
				</section>
				<!--<section>
					<a href="https://plnkr.co/edit/IqexueV4QKT7JgDOcudA?p=preview" target="_blank">Observable vs Promise [ng2]</a>
				</section>-->
				<section>
					<section>
						<h2>Cold vs hot observable</h2>
						<p class="fragment">Producer (изготовитель) - это некоторый поток, который генерирует данные и передает их в observable.</p>
					</section>
					<section>
						<h3>Cold observable</h3>
						<ol class="postList">
							<li class="fragment">Создает producer</li>
							<li class="fragment">Активирует producer</li>
							<li class="fragment">Начинате слушать producer</li>
							<li class="fragment">индивидуальный (unicast)</li></ol>
					</section>
					<section>
						<h3>Hot observable</h3>
						<ol class="postList">
							<li class="fragment">ссылается producer</li>
							<li class="fragment">Начинате слушать producer</li>
							<li class="fragment">многоадресный (multicast)</li>
					</section>
					<section>
						<div>
							<h5> Cold observable <a href="https://plnkr.co/edit/s2vriUDpbtqEPk1t1IZv?p=preview" target="_blank">[ng2]</a></h5>
							<pre><code class="hljs javascript">
const source = new Observable((observer) => {
  const socket = new WebSocket('ws://someurl');
  socket.addEventListener('message', (e) => observer.next(e));
  return () => socket.close();
});
							</code></pre>
						</div>
						<br><br>
						<div class="fragment">
							<h5> Hot observable </h5>
							<pre><code class="hljs javascript">
const socket = new WebSocket('ws://someurl');
const source = new Observable((observer) => {
  socket.addEventListener('message', (e) => observer.next(e));
});
							</code></pre>
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>Примеры операторов</h2>
					</section>
					<section>
						<h3>concat</h3>
						<p>когда важен порядок вывода последовательностей.</p>
						<pre><code class="hljs javascript">
const getPostOne$ = Rx.Observable.timer(3000).mapTo({id: 1});
const getPostTwo$ = Rx.Observable.timer(1000).mapTo({id: 2});

Rx.Observable
	.concat(getPostOne$, getPostTwo$)
	.subscribe(res => console.log(res));
						</code></pre>
						<img src="./images/concat.gif"/>
					</section>
					<section>
						<h3>forkJoin</h3>
						<p> аналог Promise.all()</p>
						<pre><code class="hljs javascript">
const getPostOne$ = Rx.Observable.timer(1000).mapTo({id: 1});
const getPostTwo$ = Rx.Observable.timer(2000).mapTo({id: 2});

Rx.Observable
	.forkJoin(getPostOne$, getPostTwo$)
	.subscribe(res => console.log(res))
						</code></pre>
						<img src="./images/forjoin.gif"/>
					</section>
					<section>
						<h3>mergeMap</h3>
						<p>чтобы все элементы внутренние Observable порождали событие основного.</p>
						<pre><code class="hljs javascript">
const post$ = Rx.Observable.of({id: 1});
const getPostInfo$ = Rx.Observable
	.timer(3000).mapTo({title: "Post title"});

const posts$ = post$
	.mergeMap(post => getPostInfo$)
	.subscribe(res => console.log(res));
						</code></pre>
						<img src="./images/mergemap.gif"/>
					</section>
					<section>
						<h3>pairwise</h3>
						<p>возвращает не только текущее значение, но в месте с ним и предыдущее значение последовательности</p>
						<pre><code class="hljs javascript">
// Tracking the scroll delta
Rx.Observable
  .fromEvent(document, 'scroll')
  .map(e => window.pageYOffset)
  .pairwise()
  .subscribe(pair => console.log(pair)); // pair[1] - pair[0]
						</code></pre>
						<img src="./images/pairwise.gif"/>
					</section>
				</section>
				<section>
					<section>
						<h2>Еще несколько примеров операторов</h2>
					</section>
					<section>
						<h3>map</h3>
						<img src="images/map.png">
					</section>
					<section>
						<h3>filter</h3>
						<img src="images/filter.png">
					</section>
					<section>
						<h3>scan</h3>
						<img src="images/scan.png">
					</section>
					<section>
						<h3>do</h3>
						<img src="images/do.png">
					</section>
					<section>
						<h3>withLatestFrom</h3>
						<img style="height: 25rem;" src="images/withLatestFrom.png">
					</section>
					<section>
						<h3>combineLatest</h3>
						<img style="height: 25rem;" src="images/combineLatest.png">
					</section>
				</section>
				<section>
						<h3><a href="http://rxmarbles.com/">
							Interactive diagrams of Rx Observables
						</a></h3>
				</section>
				<section>
					<h3>links</h3>
					<ul>
						<li><a href="https://www.youtube.com/watch?v=3cGKw9sxV_g">
							holyJS 2016 Piter Виктор Русакович
						</li>
						<li><a href="http://stepansuvorov.com/blog/2017/03/rxjs-6-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B2%D1%8B-%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C/">
							Rxjs: 6 операторов, которые вы должны знать
						</a></li>
						<li><a href="https://habrahabr.ru/post/325660/">
							практический обзор FRP библиотек
						</a></li>
						<li><a href="https://dou.ua/lenta/articles/reactive-libraries/">
							Реактивные библиотеки RX
						</a></li>
						<li><a href="http://xgrommx.github.io/rx-book/index.html">
							rx-book Денис Стоянов
						</a></li>
						<li><a href="http://rxmarbles.com/">
							Interactive diagrams of Rx Observables
						</a></li>
						<li><a href="https://egghead.io/lessons/rxjs-rxjs-observables-vs-promises">
							Observables vs Promises
						</a></li>
						<li><a href="https://github.com/dakolech/ng2-rxjs-prolog">
							ng2 rxjs prolog
						</a></li>
					</ul>
				</section>
				<section>
					<h3>Спасибо! Вопросы?</h3>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
